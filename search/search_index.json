{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Introductions # The unofficial FIRST Robotics Competition Java Programming Tutorial. Info Updated for the 2019 Season Last updated: 10/31/19 Disclaimer: Some screenshots may have different colors, icons, more/less folders/files than you due to themes or personal settings. This is normal and should not impact the tutorial. If you still have any questions please contact us. Powered by # Contributors # Name Team Team Role Tayler Uva 3255 Mentor Isaac Sayasane 3255 Alumni Sharon Riggs 6995 Mentor","title":"Introductions"},{"location":"index.html#introductions","text":"The unofficial FIRST Robotics Competition Java Programming Tutorial. Info Updated for the 2019 Season Last updated: 10/31/19 Disclaimer: Some screenshots may have different colors, icons, more/less folders/files than you due to themes or personal settings. This is normal and should not impact the tutorial. If you still have any questions please contact us.","title":"Introductions"},{"location":"index.html#powered-by","text":"","title":"Powered by"},{"location":"index.html#contributors","text":"Name Team Team Role Tayler Uva 3255 Mentor Isaac Sayasane 3255 Alumni Sharon Riggs 6995 Mentor","title":"Contributors"},{"location":"contributing.html","text":"Contributing # Helping out with the project! Example Project Code # If you make Example Project Code changes please contribute changes that reflect this in the Documentation. This will make it easier for us and more likely that your contribution will be approved. Documentation # If you make documentation changes please contribute changes that reflect this in the Example Project Code. This will make it easier for us and more likely that your contribution will be approved. Editing Pages # On each page there is an option to edit the page. Any changes you make through this option will be submitted and become live once they are approved. This icon looks like this: Alternatively you could create a pull request and clone the repository New Pages # You can help the project by making new pages. Any pages you make will become live once they are approved. Click here to create a new page Alternatively you could create a pull request and clone the repository Warning Make sure all documentation files end in .md Tip You can add to a certain subdirectory by appending /director_name/ to the file name Template # Please copy this code as a template to create your new page <!-- This page was contributed by: --> # Page title Subtitle <!-- Add a page image to make it pretty! --> ![Image Title](imageURL) ## Section One - Some info - Some other into - Some sub info *** ## Section Two - Info - Info 2","title":"Contributing"},{"location":"contributing.html#contributing","text":"Helping out with the project!","title":"Contributing"},{"location":"contributing.html#example-project-code","text":"If you make Example Project Code changes please contribute changes that reflect this in the Documentation. This will make it easier for us and more likely that your contribution will be approved.","title":"Example Project Code"},{"location":"contributing.html#documentation","text":"If you make documentation changes please contribute changes that reflect this in the Example Project Code. This will make it easier for us and more likely that your contribution will be approved.","title":"Documentation"},{"location":"contributing.html#editing-pages","text":"On each page there is an option to edit the page. Any changes you make through this option will be submitted and become live once they are approved. This icon looks like this: Alternatively you could create a pull request and clone the repository","title":"Editing Pages"},{"location":"contributing.html#new-pages","text":"You can help the project by making new pages. Any pages you make will become live once they are approved. Click here to create a new page Alternatively you could create a pull request and clone the repository Warning Make sure all documentation files end in .md Tip You can add to a certain subdirectory by appending /director_name/ to the file name","title":"New Pages"},{"location":"contributing.html#template","text":"Please copy this code as a template to create your new page <!-- This page was contributed by: --> # Page title Subtitle <!-- Add a page image to make it pretty! --> ![Image Title](imageURL) ## Section One - Some info - Some other into - Some sub info *** ## Section Two - Info - Info 2","title":"Template"},{"location":"basics/driverstation_tips.html","text":"","title":"Driverstation tips"},{"location":"basics/java_basics.html","text":"Java Programming Basics # Learning What's What Overview # Objects, variables, and classes (in Java) make up our programs. We define, modify, use these variables and objects to make our programs run. Programs use key words to define characteristics of variables or objects. Basic keywords: public - an object accessible by other classes (files) private - an object only accessible by its containing class (file). protected - like private but can be seen by subclasses return - value to return or give back after method execution (run). void - a method that returns no value null - a value that means empty or nothing IMPORTANT NOTE Java is case sensitive, meaning capitalization matters! Classes # Classes are the files that contain our programming A program can be made up of one class but can also be made up of many classes All programs run a main class that can optionally load additional classes either directly or indirectly Example main loads class1, class1 loads class2 Classes are made up of variables and methods and are often used to separate and organize your code. Classes can also call (use) variables or methods of other classes if those have been set to public. Constructors # Classes can also have a constructor which is a special type of method that has the same name (case sensitive) as the class file Constructors are always called when the class is loaded into the program for the first time. This is often the only time they are called. Constructors are called when trying to access the class in other files. They can be called again if the class is programmed to be unloaded (destroyed) and reloaded. Calls to methods, and assignment of values, within the constructor will run as soon as the class is called (loaded) in the code. Methods # Methods, also known as functions, can be thought of as subprograms or routines that run inside of your main program. Methods are used when you want to run the same code multiple times. Copying and pasting code is BAD! Use methods instead! Methods are also useful to access only certain parts or functions of another class. Methods can also have their own variables ( local ) or use variables available throughout the whole class ( global variables ), this will be explained more in the scope section . Methods can call (use) other methods, even multiple times. Example int value ; void increment (){ value ++; } Parameters # Parameters are variables that are passed (sent) to a method for it to use. You can pass more than one parameter but order matters when calling the method. Example // Example of a method with a parameter double half ( int num1 ){ double multiplier = 0.5 ; return num1 * multiplier ; } int newNumber = half ( 12 ); // <---- Method being called (used) in code Variables # Variables are objects that contain data, they are characterized by data types Variables are assigned names and data types on creation Names can be anything with the exception of pre-existing keywords such as public or int Data types define what type of data is being stored in the variables: int - integers (whole numbers) double - double precision floating point (fractional/decimal values) boolean - true or false (true = 1 or false = 0) values. string - text values contained in parentheses Example: int sum ; A variable that can hold whole number values Example: boolean isFull = true ; A variable can either hold a true or false value and is being assigned a true value Constants # Most variables can have their values assigned or reassigned at any point elsewhere in your program. To avoid having a variable change its value during runtime you can make it a constant In Java you can create constants using the static final keywords together in front of the data type of the variable The static modifier causes the variable to be available without loading an the class where it is defined. The final modifier causes the variable to be unchangeable. Java constants are normally declared in ALL CAPS. Words in Java constants are normally separated by underscores. Example: public static final double PI_VALUE = 3.14159 ; A variable that cannot be modified during code run time. Scope # When creating a variable, where you create it matters. This is known as the scope of a variable. The scope is where a variable can be seen within a class A variable created in a method can only be seen in that method. This is a local variable. A variable created outside a method can be seen in all methods of that class (file). This is a global variable. It is good practice to put them all at the top before your first method. Example of a Local Variable public int testMethod () { int example = 12 ; // Inside of method example = example + 1 ; return example } Example of a Public Variable int example = 12 ; // Outside of method public void testMethod () { example = example + 1 ; return example } Comments # Comments are a programmer-readable explanation or annotation in the source code of a program. Comments do not affect what the code does. Comments are often used to leave notes or explanations of what methods or classes are doing so that it is easier to understand the code. Example: Single Line Comments // This is what a single line comment looks like // You can also have multiple // single line comments in a row Example: Multi Line Comments /* This is what a multiline comment looks like */ Example: Doc Comments /** * This is a doc comment * * <ul> * <li>They can be viewed by hovering over code they are attached to</li> * <li>They can be formatted with HTML</li> * </ul> */ Conventions # There are also many different conventions when programming, this ensures that programs are readable between different people. A common naming convention: Programming is often done in CamelCase or lowerCamelCase Instead of adding spaces, capitalize the first letter of each word Example ThreeMotorDrive, driveForward, setSpeed Info There are other naming conventions, but for this tutorial we will use the camel cases","title":"Java Programming Basics"},{"location":"basics/java_basics.html#java-programming-basics","text":"Learning What's What","title":"Java Programming Basics"},{"location":"basics/java_basics.html#overview","text":"Objects, variables, and classes (in Java) make up our programs. We define, modify, use these variables and objects to make our programs run. Programs use key words to define characteristics of variables or objects. Basic keywords: public - an object accessible by other classes (files) private - an object only accessible by its containing class (file). protected - like private but can be seen by subclasses return - value to return or give back after method execution (run). void - a method that returns no value null - a value that means empty or nothing IMPORTANT NOTE Java is case sensitive, meaning capitalization matters!","title":"Overview"},{"location":"basics/java_basics.html#classes","text":"Classes are the files that contain our programming A program can be made up of one class but can also be made up of many classes All programs run a main class that can optionally load additional classes either directly or indirectly Example main loads class1, class1 loads class2 Classes are made up of variables and methods and are often used to separate and organize your code. Classes can also call (use) variables or methods of other classes if those have been set to public.","title":"Classes"},{"location":"basics/java_basics.html#constructors","text":"Classes can also have a constructor which is a special type of method that has the same name (case sensitive) as the class file Constructors are always called when the class is loaded into the program for the first time. This is often the only time they are called. Constructors are called when trying to access the class in other files. They can be called again if the class is programmed to be unloaded (destroyed) and reloaded. Calls to methods, and assignment of values, within the constructor will run as soon as the class is called (loaded) in the code.","title":"Constructors"},{"location":"basics/java_basics.html#methods","text":"Methods, also known as functions, can be thought of as subprograms or routines that run inside of your main program. Methods are used when you want to run the same code multiple times. Copying and pasting code is BAD! Use methods instead! Methods are also useful to access only certain parts or functions of another class. Methods can also have their own variables ( local ) or use variables available throughout the whole class ( global variables ), this will be explained more in the scope section . Methods can call (use) other methods, even multiple times. Example int value ; void increment (){ value ++; }","title":"Methods"},{"location":"basics/java_basics.html#parameters","text":"Parameters are variables that are passed (sent) to a method for it to use. You can pass more than one parameter but order matters when calling the method. Example // Example of a method with a parameter double half ( int num1 ){ double multiplier = 0.5 ; return num1 * multiplier ; } int newNumber = half ( 12 ); // <---- Method being called (used) in code","title":"Parameters"},{"location":"basics/java_basics.html#variables","text":"Variables are objects that contain data, they are characterized by data types Variables are assigned names and data types on creation Names can be anything with the exception of pre-existing keywords such as public or int Data types define what type of data is being stored in the variables: int - integers (whole numbers) double - double precision floating point (fractional/decimal values) boolean - true or false (true = 1 or false = 0) values. string - text values contained in parentheses Example: int sum ; A variable that can hold whole number values Example: boolean isFull = true ; A variable can either hold a true or false value and is being assigned a true value","title":"Variables"},{"location":"basics/java_basics.html#constants","text":"Most variables can have their values assigned or reassigned at any point elsewhere in your program. To avoid having a variable change its value during runtime you can make it a constant In Java you can create constants using the static final keywords together in front of the data type of the variable The static modifier causes the variable to be available without loading an the class where it is defined. The final modifier causes the variable to be unchangeable. Java constants are normally declared in ALL CAPS. Words in Java constants are normally separated by underscores. Example: public static final double PI_VALUE = 3.14159 ; A variable that cannot be modified during code run time.","title":"Constants"},{"location":"basics/java_basics.html#scope","text":"When creating a variable, where you create it matters. This is known as the scope of a variable. The scope is where a variable can be seen within a class A variable created in a method can only be seen in that method. This is a local variable. A variable created outside a method can be seen in all methods of that class (file). This is a global variable. It is good practice to put them all at the top before your first method. Example of a Local Variable public int testMethod () { int example = 12 ; // Inside of method example = example + 1 ; return example } Example of a Public Variable int example = 12 ; // Outside of method public void testMethod () { example = example + 1 ; return example }","title":"Scope"},{"location":"basics/java_basics.html#comments","text":"Comments are a programmer-readable explanation or annotation in the source code of a program. Comments do not affect what the code does. Comments are often used to leave notes or explanations of what methods or classes are doing so that it is easier to understand the code. Example: Single Line Comments // This is what a single line comment looks like // You can also have multiple // single line comments in a row Example: Multi Line Comments /* This is what a multiline comment looks like */ Example: Doc Comments /** * This is a doc comment * * <ul> * <li>They can be viewed by hovering over code they are attached to</li> * <li>They can be formatted with HTML</li> * </ul> */","title":"Comments"},{"location":"basics/java_basics.html#conventions","text":"There are also many different conventions when programming, this ensures that programs are readable between different people. A common naming convention: Programming is often done in CamelCase or lowerCamelCase Instead of adding spaces, capitalize the first letter of each word Example ThreeMotorDrive, driveForward, setSpeed Info There are other naming conventions, but for this tutorial we will use the camel cases","title":"Conventions"},{"location":"basics/roboRIO.html","text":"roboRIO # The Brains of the Bot! The roboRIO Basics # The roboRIO is the brain of an FRC robot. It is the main processing unit and is where the code is stored and run. It is very similar to something like a Raspberry Pi, it\u2019s a mini computer! The roboRIO can connect to many different devices such as motor controllers, servos, and sensors through its various interface connections such as: Digital I/O, PWM, CAN Bus, Ethernet, USB, MXP The roboRIO IO # Digital IO (DIO) used for sensors and switches PWM used for motor controllers and servos CAN used for motor controllers and sensors MXP used for functionality expansion Check the roboRIO user manual for more details","title":"roboRIO"},{"location":"basics/roboRIO.html#roborio","text":"The Brains of the Bot!","title":"roboRIO"},{"location":"basics/roboRIO.html#the-roborio-basics","text":"The roboRIO is the brain of an FRC robot. It is the main processing unit and is where the code is stored and run. It is very similar to something like a Raspberry Pi, it\u2019s a mini computer! The roboRIO can connect to many different devices such as motor controllers, servos, and sensors through its various interface connections such as: Digital I/O, PWM, CAN Bus, Ethernet, USB, MXP","title":"The roboRIO Basics"},{"location":"basics/roboRIO.html#the-roborio-io","text":"Digital IO (DIO) used for sensors and switches PWM used for motor controllers and servos CAN used for motor controllers and sensors MXP used for functionality expansion Check the roboRIO user manual for more details","title":"The roboRIO IO"},{"location":"basics/sensors.html","text":"Sensors # How does the robot see? Some types of sensors # Limit Switches - detects contact Camera - provides sight Encoders - measures rotational or linear motion Ultrasonic - measures distances Gyroscope - measures orientation Processed Vision - measures target's distance, angle, and offset from robot For more info on sensors see: High Tech High Top Hat Technicians - Electrical Tutorial Limit Switch Grayhill brand Quadrature Encoder Kauai Labs navX Gyro/ Accelerometer","title":"Sensors"},{"location":"basics/sensors.html#sensors","text":"How does the robot see?","title":"Sensors"},{"location":"basics/sensors.html#some-types-of-sensors","text":"Limit Switches - detects contact Camera - provides sight Encoders - measures rotational or linear motion Ultrasonic - measures distances Gyroscope - measures orientation Processed Vision - measures target's distance, angle, and offset from robot For more info on sensors see: High Tech High Top Hat Technicians - Electrical Tutorial Limit Switch Grayhill brand Quadrature Encoder Kauai Labs navX Gyro/ Accelerometer","title":"Some types of sensors"},{"location":"basics/vscode_tips.html","text":"Visual Studio Code Tips # Making life easier \ud83d\udca1 Using the light bulb (quick fixes) # When auto complete is available, click enter on the correct completion to auto import classes. If this is not done an error can occur denoted by an underline on what you just typed. To fix this, click on the error and click the light bulb that pops up. Then click import. From this point on this tutorial will assume you are doing this on your own so if errors occur, click the light bulb and see if it suggest importing something. The light bulb can also be used to make programming easier by auto creating things for us. This tutorial will go over that in future sections","title":"Visual Studio Code Tips"},{"location":"basics/vscode_tips.html#visual-studio-code-tips","text":"Making life easier","title":"Visual Studio Code Tips"},{"location":"basics/vscode_tips.html#using-the-light-bulb-quick-fixes","text":"When auto complete is available, click enter on the correct completion to auto import classes. If this is not done an error can occur denoted by an underline on what you just typed. To fix this, click on the error and click the light bulb that pops up. Then click import. From this point on this tutorial will assume you are doing this on your own so if errors occur, click the light bulb and see if it suggest importing something. The light bulb can also be used to make programming easier by auto creating things for us. This tutorial will go over that in future sections","title":"\ud83d\udca1 Using the light bulb (quick fixes)"},{"location":"basics/wpilib.html","text":"WPILib Programming Basics # Making FRC Programming Easy What is WPILib # The WPI Robotics library (WPILib) is a set of software classes that interfaces with the hardware and software in your FRC RoboRIO. There are classes to handle sensors, motor speed controllers, the driver station, and a number of other utility functions. Documentation is available at http://first.wpi.edu/FRC/roborio/release/docs/java WPILib adds those sensors and controllers as additional data types (like int or double ) and classes. Examples Talon , Solenoid , Encoder ... Command Based Robot # For our programming tutorial we will be creating a Command based robot Command Based Robots are much like Lego, with very basic pieces you can make something simple like a house or complicated like a replica Star Wars Millennium Falcon A command based robot is broken down into subsystem classes and command classes. In the code, a command based robot is made up of 3 packages ( folders ) labeled robot, commands, and subsystems There are other types of robots but we will use Command Based Subsystems # A subsystem is a special template class made by FRC. In robotics, subsystems are sections of the whole robot. For example every FRC robot has a Drivetrain subsystem which is what controls the robot\u2019s driving both physically and programmatically. To avoid confusion between software and mechanical teams, subsystems should be called the same thing. If we have a ball intake system, we will both call it Intake or Collector . Subsystems of a robot can contain parts to control or read data from. The Drivetrain subsystem could contain motor controllers and encoders both physically and programmatically. Using a dog as an example: the legs , tail , and head are subsystems . The head subsystem has the parts: eyes , ears , and nose . When programming subsystems we use variables and methods to tell our subsystem what it has and what it is capable of or should do. These variables will be the parts in the subsystem These methods will define what those parts are capable of. Using a dog head subsystem as an example: Some variables (parts) would be: leftEye , rightEye , nose , leftEar , rightEar . Some example methods would be closeEyes or openEyes since these are things the dog are capable of. These methods would use both the leftEye and rightEye and close them. Example //This method closes the dog eyes public void closeEyes (){ leftEye . close (); rightEye . close (); A robot example of a Drivetrain subsystem would have leftMotor , and rightMotor as variables and setSpeed as a method telling it how to set the speed of those motor controllers. Having the setSpeed method tells our program that our Drivetrain subsystem can set its speed. Example //This method sets the speed of the drivetrain public void setSpeed ( double speed ){ leftMotor . set ( speed ); rightMotor . set ( speed ); } Commands # A command is a special template class (file) made by FRC. In robotics, commands are actions you want a robot to do (just like a real life command). A command is an action a subsystem(s) performs. For example you may want your robot to drive full speed forward so you make a command class called DriveForward . Since a robot uses a Drivetrain subsystem to control its motors, this command would call our previously created setSpeed method from that subsystem. Tip Subsystems define what the robot is made of and what it can do while commands actually tell the robot to do those things Using a dog as an example we can tell the dog to blink by creating a BlinkEyes command The command would call the method, closeEyes() then the method openEyes() BlinkEyes Command //This command will continuously run the two methods in execute protected void execute () { dog . head . closeEyes (); dog . head . openEyes (); } A robot example of a DriveForward command would call (use) the setSpeed methods that we created in the Drivetrain subsystem DriveForward , when executed, will tell our robot to drive forward using the Drivetrain subsystem DriveForward Command //This command tells the robot to drive forward full speed protected void initialize (){ robot . drivetrain . setSpeed ( 1.0 ); } Default Command Structure # The template for FRC commands actually come with some pre-defined methods that have special properties for FRC robots, they are: void initialize () - Methods in here are called just before this Command runs the first time. void execute () - Methods in here are called repeatedly when this Command is scheduled to run boolean isFinished () - When this returns true, the Command stops running execute() void end () - Methods in here are called once after isFinished returns true void interrupted () - Methods in here are called when another command which requires one or more of the same subsystems is scheduled to run Tip It is good practice to call end() in interrupted() Overview of execution # In FRC programming our main class is Robot.java and all other classes (command files and subsystem files) must be loaded from Robot.java either directly or indirectly Example Robot.java loads OI.java , OI.java loads DriveForward.java . All subsystem files must be added to Robot.java \u2019s auto-created robotInit () method. This loads our subsystems into the code and allow its public methods to be useable by other files such as commands later by typing Robot . nameOfSubsystem . desiredMethod (); New Project Files # When creating a new command based robot project, the following classes (files) will be created: Robot.java - The main class of the robot which is run when a robot boots up. OI.java - This class binds our commands to a physical operator interface such as a joystick or controller. This file is already in robotInit () by default so classes called here will also be loaded by the program RobotMap.java - This class is used to hold all the ports or ID numbers of sensors or devices connected to the robot and assign them a variable name. This provides flexibility changing wiring, makes checking the wiring easier and significantly reduces the number of magic numbers floating around. ExampleSubsystem.java and ExampleCommand.java are auto-created examples. Summary # Command based robots are broken down into subsystems and commands Subsystems define what the robot is made of and what it can do while commands actually tell the robot to do those things All classes must directly or indirectly connect to Robot.java . All Subsystems must be added to Robot.java \u2019s robotInit () RobotMap.java holds port numbers and IDs accessible throughout the program by typing: RobotMap . NameOfMotor () OI.java connects our commands to physical controllers","title":"WPILib Programming Basics"},{"location":"basics/wpilib.html#wpilib-programming-basics","text":"Making FRC Programming Easy","title":"WPILib Programming Basics"},{"location":"basics/wpilib.html#what-is-wpilib","text":"The WPI Robotics library (WPILib) is a set of software classes that interfaces with the hardware and software in your FRC RoboRIO. There are classes to handle sensors, motor speed controllers, the driver station, and a number of other utility functions. Documentation is available at http://first.wpi.edu/FRC/roborio/release/docs/java WPILib adds those sensors and controllers as additional data types (like int or double ) and classes. Examples Talon , Solenoid , Encoder ...","title":"What is WPILib"},{"location":"basics/wpilib.html#command-based-robot","text":"For our programming tutorial we will be creating a Command based robot Command Based Robots are much like Lego, with very basic pieces you can make something simple like a house or complicated like a replica Star Wars Millennium Falcon A command based robot is broken down into subsystem classes and command classes. In the code, a command based robot is made up of 3 packages ( folders ) labeled robot, commands, and subsystems There are other types of robots but we will use Command Based","title":"Command Based Robot"},{"location":"basics/wpilib.html#subsystems","text":"A subsystem is a special template class made by FRC. In robotics, subsystems are sections of the whole robot. For example every FRC robot has a Drivetrain subsystem which is what controls the robot\u2019s driving both physically and programmatically. To avoid confusion between software and mechanical teams, subsystems should be called the same thing. If we have a ball intake system, we will both call it Intake or Collector . Subsystems of a robot can contain parts to control or read data from. The Drivetrain subsystem could contain motor controllers and encoders both physically and programmatically. Using a dog as an example: the legs , tail , and head are subsystems . The head subsystem has the parts: eyes , ears , and nose . When programming subsystems we use variables and methods to tell our subsystem what it has and what it is capable of or should do. These variables will be the parts in the subsystem These methods will define what those parts are capable of. Using a dog head subsystem as an example: Some variables (parts) would be: leftEye , rightEye , nose , leftEar , rightEar . Some example methods would be closeEyes or openEyes since these are things the dog are capable of. These methods would use both the leftEye and rightEye and close them. Example //This method closes the dog eyes public void closeEyes (){ leftEye . close (); rightEye . close (); A robot example of a Drivetrain subsystem would have leftMotor , and rightMotor as variables and setSpeed as a method telling it how to set the speed of those motor controllers. Having the setSpeed method tells our program that our Drivetrain subsystem can set its speed. Example //This method sets the speed of the drivetrain public void setSpeed ( double speed ){ leftMotor . set ( speed ); rightMotor . set ( speed ); }","title":"Subsystems"},{"location":"basics/wpilib.html#commands","text":"A command is a special template class (file) made by FRC. In robotics, commands are actions you want a robot to do (just like a real life command). A command is an action a subsystem(s) performs. For example you may want your robot to drive full speed forward so you make a command class called DriveForward . Since a robot uses a Drivetrain subsystem to control its motors, this command would call our previously created setSpeed method from that subsystem. Tip Subsystems define what the robot is made of and what it can do while commands actually tell the robot to do those things Using a dog as an example we can tell the dog to blink by creating a BlinkEyes command The command would call the method, closeEyes() then the method openEyes() BlinkEyes Command //This command will continuously run the two methods in execute protected void execute () { dog . head . closeEyes (); dog . head . openEyes (); } A robot example of a DriveForward command would call (use) the setSpeed methods that we created in the Drivetrain subsystem DriveForward , when executed, will tell our robot to drive forward using the Drivetrain subsystem DriveForward Command //This command tells the robot to drive forward full speed protected void initialize (){ robot . drivetrain . setSpeed ( 1.0 ); }","title":"Commands"},{"location":"basics/wpilib.html#default-command-structure","text":"The template for FRC commands actually come with some pre-defined methods that have special properties for FRC robots, they are: void initialize () - Methods in here are called just before this Command runs the first time. void execute () - Methods in here are called repeatedly when this Command is scheduled to run boolean isFinished () - When this returns true, the Command stops running execute() void end () - Methods in here are called once after isFinished returns true void interrupted () - Methods in here are called when another command which requires one or more of the same subsystems is scheduled to run Tip It is good practice to call end() in interrupted()","title":"Default Command Structure"},{"location":"basics/wpilib.html#overview-of-execution","text":"In FRC programming our main class is Robot.java and all other classes (command files and subsystem files) must be loaded from Robot.java either directly or indirectly Example Robot.java loads OI.java , OI.java loads DriveForward.java . All subsystem files must be added to Robot.java \u2019s auto-created robotInit () method. This loads our subsystems into the code and allow its public methods to be useable by other files such as commands later by typing Robot . nameOfSubsystem . desiredMethod ();","title":"Overview of execution"},{"location":"basics/wpilib.html#new-project-files","text":"When creating a new command based robot project, the following classes (files) will be created: Robot.java - The main class of the robot which is run when a robot boots up. OI.java - This class binds our commands to a physical operator interface such as a joystick or controller. This file is already in robotInit () by default so classes called here will also be loaded by the program RobotMap.java - This class is used to hold all the ports or ID numbers of sensors or devices connected to the robot and assign them a variable name. This provides flexibility changing wiring, makes checking the wiring easier and significantly reduces the number of magic numbers floating around. ExampleSubsystem.java and ExampleCommand.java are auto-created examples.","title":"New Project Files"},{"location":"basics/wpilib.html#summary","text":"Command based robots are broken down into subsystems and commands Subsystems define what the robot is made of and what it can do while commands actually tell the robot to do those things All classes must directly or indirectly connect to Robot.java . All Subsystems must be added to Robot.java \u2019s robotInit () RobotMap.java holds port numbers and IDs accessible throughout the program by typing: RobotMap . NameOfMotor () OI.java connects our commands to physical controllers","title":"Summary"},{"location":"programming/autonomous.html","text":"WIP Creating an Autonomous Command # This page is currently a work in progress. Check back later","title":"**WIP** Creating an Autonomous Command"},{"location":"programming/autonomous.html#wip-creating-an-autonomous-command","text":"This page is currently a work in progress. Check back later","title":"WIP Creating an Autonomous Command"},{"location":"programming/deploying.html","text":"Deploying Robot Code # How to deploy # Hardware # To deploy code, first make sure your computer is connected to the robot in ONE of the following ways: USB Ethernet Robot's Wireless Network Software # Note Make sure your team number in wpilib_preferences.json in the .wpilib folder is set to the same team number your roboRIO was programmed for (it should be the number you set when creating the project and you will NOT need to check this every time as it should not change by itself). 1) Select the W icon from the tab bar or use the shortcut by holding down Ctrl+Shift+P at the same time. (Replace ctrl with cmd on macOS) 2) Type and hit enter or select: WPILib: Deploy Robot Code Tip Alternatively you can do one of the following: Use Shift+F5 at any time to deploy. (you may also need to hold fn depending on your computer configuration) Right-click on the build.gradle file in the project hierarchy and select \"Build Robot Code\u201d Open the shortcut menu indicated by the ellipses in the top right corner of the VS Code window and select \"Build Robot Code\" Testing # Open up the DriverStation software on any computer that has it installed. Enable the robot Try moving the joysticks on your controller when enabled. If it doesn\u2019t, check your port numbers for your controller, axes, and motor controllers","title":"Deploying Robot Code"},{"location":"programming/deploying.html#deploying-robot-code","text":"","title":"Deploying Robot Code"},{"location":"programming/deploying.html#how-to-deploy","text":"","title":"How to deploy"},{"location":"programming/deploying.html#hardware","text":"To deploy code, first make sure your computer is connected to the robot in ONE of the following ways: USB Ethernet Robot's Wireless Network","title":"Hardware"},{"location":"programming/deploying.html#software","text":"Note Make sure your team number in wpilib_preferences.json in the .wpilib folder is set to the same team number your roboRIO was programmed for (it should be the number you set when creating the project and you will NOT need to check this every time as it should not change by itself). 1) Select the W icon from the tab bar or use the shortcut by holding down Ctrl+Shift+P at the same time. (Replace ctrl with cmd on macOS) 2) Type and hit enter or select: WPILib: Deploy Robot Code Tip Alternatively you can do one of the following: Use Shift+F5 at any time to deploy. (you may also need to hold fn depending on your computer configuration) Right-click on the build.gradle file in the project hierarchy and select \"Build Robot Code\u201d Open the shortcut menu indicated by the ellipses in the top right corner of the VS Code window and select \"Build Robot Code\"","title":"Software"},{"location":"programming/deploying.html#testing","text":"Open up the DriverStation software on any computer that has it installed. Enable the robot Try moving the joysticks on your controller when enabled. If it doesn\u2019t, check your port numbers for your controller, axes, and motor controllers","title":"Testing"},{"location":"programming/driving_robot.html","text":"Creating a Basic Driving Robot # Lets get moving! Picture source: Team 2984 Overview # In this section we will be going over: Creating the basic Drivetrain subsystem Adding subsystems to Robot.java, the main file that the robot runs and all other files must be in some way connected to. Creating joysticks and using their axes to control the robot. Creating and using DifferentialDrive and ArcadeDrive to make controlling the robot\u2019s motors an easy process. Deploying code to the roboRIO Creating the Drivetrain Subsystem # Before we begin we must create the class file for the drivetrain subsystem. See Creating a New Subsystem for info on how to do this. What will be added to the Drivetrain # In the Drivetrain class we will tell the subsystem what type of components it will be using. A Drivetrain needs motor controllers. In our case we will use 4 Talon SRs (a brand of controller for motors). You could use other motor controllers such as Victor SPs or Talon SRXs but we will be using Talon SRs If you are, replace Talon with TalonSRX, Victor, or VictorSP in the code you write depending on the type you use. You can use 2 motors (left and right), but for this tutorial we will use 4. Tip Be sure to read Visual Studio Code Tips before getting started! It will make your life a lot easier. Creating the Talon Variables # 1) Create 4 global variables of data type Talon and name them: leftFrontTalon , rightFrontTalon , leftBackTalon , rightBackTalon To get started type the word Talon followed by the name i.e. Talon leftFrontTalon ; These will eventually hold the object values for Talons and their port numbers. 2) Next assign their values to null ( more info on null ). We do this to make sure it is empty at this point. When we assign these variables a value, we will be getting the motor controller's port numbers out of RobotMap This means we cannot assign them at the global level Example The code you typed should be this: Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; Your full Drivetrain.java should look like this: package frc.robot.subsystems ; import edu.wpi.first.wpilibj.Talon ; import edu.wpi.first.wpilibj.command.Subsystem ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } } If an error occurs (red squiggles) Click the word Talon \ud83d\udca1 Click the light bulb Select \"Import 'Talon' (edu.wpi.first.wpilibj)\" Your error should be gone! Creating and filling the constructor # 1) Create the constructor for Drivetrain.java ( more info on constructors ) The constructor is where we will assign values to our talon variables. Now that we have created the Talons we must initialize them and tell them what port on the roboRIO they are on. 2) Initialize (set value of) leftFrontTalon to new Talon ( 0 ) . This initializes a new talon, leftFrontTalon , in a new piece of memory and states it is on port 0 of the roboRIO. This should be done within the constructor Drivetrain () This calls the constructor Talon ( int ) in the Talon class. The constructor Talon ( int ) takes a variable of type int . In this case the int (integer) refers to the port number on the roboRIO. roboRIO port diagram Example The code you typed should be this: public Drivetrain () { // Talons leftFrontTalon = new Talon ( 0 ); } Your full Drivetrain.java should look like this: package frc.robot.subsystems ; import edu.wpi.first.wpilibj.Talon ; import edu.wpi.first.wpilibj.command.Subsystem ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; public Drivetrain () { // Talons leftFrontTalon = new Talon ( 0 ); } @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } } Using RobotMap # Since each subsystem has its own components with their own ports, it is easy to lose track of which ports are being used and for what. To counter this you can use a class called RobotMap to hold all these values in a single location. 1) To use RobotMap, instead of putting 0 for the port on the Talon type: RobotMap . DRIVETRAIN_LEFT_FRONT_TALON Names should follow the pattern SUBSYSTEM_NAME_OF_COMPONENT The name is all caps since it is a constant ( more info on constants ). 2) Click on the underlined text 3) Click on the \ud83d\udca1light bulb and select \u201ccreate constant\u2026\u201d 4) Click on RobotMap.java tab that just popped up 5) Change the 0 to the correct port for that motor controller on your robot/roboRIO Danger If you set this to the wrong value, you could damage your robot when it tries to move! 6) Repeat these steps for the remaining Talons. Tip Remember to save both Drivetrain.java and RobotMap.java Example The code you type should be this: leftFrontTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_FRONT_TALON ); Your full Drivetrain.java should look like this: package frc.robot.subsystems ; import edu.wpi.first.wpilibj.Talon ; import edu.wpi.first.wpilibj.command.Subsystem ; import frc.robot.RobotMap ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; public Drivetrain () { // Talons leftFrontTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_FRONT_TALON ); leftBackTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_BACK_TALON ); rightFrontTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_FRONT_TALON ); rightBackTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_BACK_TALON ); } @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } } Your full RobotMap.java should look similar to this: package frc.robot ; public class RobotMap { // Talons public static final int DRIVETRAIN_LEFT_FRONT_TALON = 0 ; public static final int DRIVETRAIN_LEFT_BACK_TALON = 1 ; public static final int DRIVETRAIN_RIGHT_FRONT_TALON = 2 ; public static final int DRIVETRAIN_RIGHT_BACK_TALON = 3 ; } Warning Remember to use the values for YOUR specific robot or you could risk damaging it! Creating the arcade drive # What is the Drive Class # The FIRST Drive class has many pre-configured methods available to us including DifferentialDrive, and many alterations of MecanumDrive. DifferentialDrive contains subsections such as TankDrive and ArcadeDrive. For our tutorial we will be creating an ArcadeDrive Arcade drives run by taking a moveSpeed and rotateSpeed. moveSpeed defines the forward and reverse speed and rotateSpeed defines the turning left and right speed. To create an arcade drive we will be using our already existing Drivetrain class and adding to it. Programing a RobotDrive # 1) In the same place we created our talons (outside of the constructor) we will create a DifferentialDrive and SpeedControllerGroups for our left and right motor controllers. Outside of the constructor type: SpeedControllerGroup leftMotors = null ; SpeedControllerGroup rightMotors = null ; DifferentialDrive differentialDrive = null ; Since DifferentialDrive only takes 2 parameters we need to create speed controller groups to combine like motor controllers together. In this case we will combine the left motors together and the right motors together. Warning You should only group motors that are spinning the same direction physically when positive power is being applied otherwise you could damage your robot. 2) Now we must initialize the SpeedControllerGroups and DifferentialDrive like we did our talons. ... In the constructor type: leftMotors = new SpeedControllerGroup ( leftFrontTalon , leftBackTalon ); rightMotors = new SpeedControllerGroup ( rightFrontTalon , rightBackTalon ); differentialDrive = new DifferentialDrive ( leftMotors , rightMotors ); Example The code you type outside the constructor should be this: SpeedControllerGroup leftMotors = null ; SpeedControllerGroup rightMotors = null ; DifferentialDrive differentialDrive = null ; The code you type inside the constructor should be this: leftMotors = new SpeedControllerGroup ( leftFrontTalon , leftBackTalon ); rightMotors = new SpeedControllerGroup ( rightFrontTalon , rightBackTalon ); differentialDrive = new DifferentialDrive ( leftMotors , rightMotors ); Your full Drivetrain.java should look like this: package frc.robot.subsystems ; import edu.wpi.first.wpilibj.SpeedControllerGroup ; import edu.wpi.first.wpilibj.Talon ; import edu.wpi.first.wpilibj.command.Subsystem ; import edu.wpi.first.wpilibj.drive.DifferentialDrive ; import frc.robot.RobotMap ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; SpeedControllerGroup leftMotors = null ; SpeedControllerGroup rightMotors = null ; DifferentialDrive differentialDrive = null ; public Drivetrain () { // Talons leftFrontTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_FRONT_TALON ); leftBackTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_BACK_TALON ); rightFrontTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_FRONT_TALON ); rightBackTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_BACK_TALON ); leftMotors = new SpeedControllerGroup ( leftFrontTalon , leftBackTalon ); rightMotors = new SpeedControllerGroup ( rightFrontTalon , rightBackTalon ); differentialDrive = new DifferentialDrive ( leftMotors , rightMotors ); } @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } } Creating the arcadeDrive method # Now it\u2019s time to make an arcadeDrive from our differentialDrive! 1) Let\u2019s create a public void method called \u201carcadeDrive\u201d with type \u201cdouble\u201d parameters moveSpeed and rotateSpeed. Below the constructor type: public void arcadeDrive ( double moveSpeed , double rotateSpeed ) { } Tip By putting something in the parentheses it makes the method require a parameter when it is used. When the method gets used and parameters are passed, they will be store in moveSpeed and rotateSpeed (in that order). See parameters for more info. 2) Now lets make our method call the differentialDrive's arcadeDrive method. Inside our method type: differentialDrive . arcadeDrive ( moveSpeed , rotateSpeed ); DifferentialDrive's arcadeDrive method takes parameters moveValue and rotateValue. Note At this point you could instead create a tank drive, however implementation differs slightly. To do so type differentialDrive . tankDrive ( moveSpeed , rotateSpeed ); instead of differentialDrive . arcadeDrive ( moveSpeed , rotateSpeed ); and change the method name reflect this. Tip If you want to limit the max speed you can multiple the speeds by a decimal (i.e. 0.5*moveSpeed will make the motors only move half of their maximum speed) You may want to do this for initial testing to make sure everything is going the right direction. Example The code you type should be this: public void arcadeDrive ( double moveSpeed , double rotateSpeed ) { differentialDrive . arcadeDrive ( moveSpeed , rotateSpeed ); } Your full Drivetrain.java should look like this: package frc.robot.subsystems ; import edu.wpi.first.wpilibj.SpeedControllerGroup ; import edu.wpi.first.wpilibj.Talon ; import edu.wpi.first.wpilibj.command.Subsystem ; import edu.wpi.first.wpilibj.drive.DifferentialDrive ; import frc.robot.RobotMap ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; SpeedControllerGroup leftMotors = null ; SpeedControllerGroup rightMotors = null ; DifferentialDrive differentialDrive = null ; public Drivetrain () { // Talons leftFrontTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_FRONT_TALON ); leftBackTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_BACK_TALON ); rightFrontTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_FRONT_TALON ); rightBackTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_BACK_TALON ); leftMotors = new SpeedControllerGroup ( leftFrontTalon , leftBackTalon ); rightMotors = new SpeedControllerGroup ( rightFrontTalon , rightBackTalon ); differentialDrive = new DifferentialDrive ( leftMotors , rightMotors ); } public void arcadeDrive ( double moveSpeed , double rotateSpeed ) { differentialDrive . arcadeDrive ( moveSpeed , rotateSpeed ); } @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } } Making our robot controllable # Creating the Joystick # In order to drive our robot, it needs to know what will be controlling it. To do so, we will create a new joystick in OI.java 1) Open OI.java 2) Type: public Joystick driverController = new Joystick ( RobotMap . OI_DRIVER_CONTROLLER ); Import any classes if necessary such as: import edu.wpi.first.wpilibj.Joystick ; A variable driverController of type Joystick pointing to a joystick on port OI_DRIVER_CONTROLLER from RobotMap 3) Click the \ud83d\udca1 light bulb to create a new CONSTANT and set the value to the port number the joystick uses on the laptop (this can be found in the Driverstation software). Example The code you type should be this: public Joystick driverController = new Joystick ( RobotMap . OI_DRIVER_CONTROLLER ); Your full OI.java should look like this: package frc.robot ; import edu.wpi.first.wpilibj.Joystick ; /** * This class is the glue that binds the controls on the physical operator * interface to the commands and command groups that allow control of the robot. */ public class OI { public Joystick driverController = new Joystick ( RobotMap . OI_DRIVER_CONTROLLER ); } Your full RobotMap.java should look similar to this: package frc.robot ; public class RobotMap { // Talons public static final int DRIVETRAIN_LEFT_FRONT_TALON = 0 ; public static final int DRIVETRAIN_LEFT_BACK_TALON = 1 ; public static final int DRIVETRAIN_RIGHT_FRONT_TALON = 2 ; public static final int DRIVETRAIN_RIGHT_BACK_TALON = 3 ; // Joysticks public static final int OI_DRIVER_CONTROLLER = 0 ; } Creating the DriveArcade Command # Remember that methods tell the robot what it can do but in order to make it do these things we must give it a command . See Command Based Robot Now that we have created the method, we need to create a command to call and use that method. Let\u2019s create a new command called DriveArcade that calls arcadeDrive method we just created! Before we begin we must create the class file for the DriveArcade command. See Creating a New Command for info on how to do this and info on what each pre-created method does. In the constructor # 1) In the constructor DriveArcade () type: requires ( Robot . m_drivetrain ); This means, this command will end all other commands currently using drivetrain and will run instead when executed. It also means, other commands that require drivetrain will stop this command and run instead when executed. Warning If you use the light bulb to import \u2018Robot\u2019. Be sure to import the one with \u201cfrc.robot\u201d In the execute method # 1) In the execute method we will create 2 variables of type double called moveSpeed and rotateSpeed. We want these variables to be the value of the axis of the controller we are using to drive the robot. So we will set them equal to that by using the joystick getRawAxis method. Controllers return an axis value between 1 and -1 to indicate how far the joystick is pushed up or down. Our personal controller returns up as -1 so we want to invert it. In Java you can put a negative \u201c - \u201cin front of a numeric value to invert it (value * -1) The joystick\u2019s getRawAxis method will get the position value of the axis as you move it. The method takes parameter \u201caxis number.\u201d (This can be found in the Driverstation software and we will store it in RobotMap). In the execute() method type: double moveSpeed = - Robot . m_oi . driverController . getRawAxis ( RobotMap . DRIVER_CONTROLLER_MOVE_AXIS ); double rotateSpeed = Robot . m_oi . driverController . getRawAxis ( RobotMap . DRIVER_CONTROLLER_ROTATE_AXIS ); Tip Remember to use the light bulb for importing and creating constants if needed! 2) Also in the execute method we will we want to call the arcadeDrive method we created in Drivetrain and give it the variables moveSpeed and rotateSpeed we created as parameters. In the execute() method below rotateSpeed type: Robot . m_drivetrain . arcadeDrive ( moveSpeed , rotateSpeed ); In the isFinished method # Since we will be using this command to control the robot we want it to run indefinitely. 1) To do this we are going to continue having isFinished return false, meaning the command will never finish. (We don't need to change anything as this is the default) Tip If we did want a command to finish, we make this return true. This can be done by replacing false with true to make it finish instantly Alternatively we can make a condition which can return true For example (timePassed > 10) will return true after 10 seconds but return false anytime before 10 seconds have passed. In the end method # 1) We will call the arcadeDrive method and give it 0 and 0 as the parameters. In the end() method type: Robot . m_drivetrain . arcadeDrive ( 0 , 0 ); This make the motors stop running when the command ends by setting the movement speed to zero and rotation speed to zero. In the interrupted method # 1) We will make it call end. In the interrupted() method type: end (); This makes the end method get called if the command gets interrupted. (No reason to re-write code, call end() to use what we already have!) Completed Example # Example Your full RobotMap.java should look similar to this: package frc.robot ; public class RobotMap { // Talons public static final int DRIVETRAIN_LEFT_FRONT_TALON = 0 ; public static final int DRIVETRAIN_LEFT_BACK_TALON = 1 ; public static final int DRIVETRAIN_RIGHT_FRONT_TALON = 2 ; public static final int DRIVETRAIN_RIGHT_BACK_TALON = 3 ; // Joysticks public static final int OI_DRIVER_CONTROLLER = 0 ; public static final int DRIVER_CONTROLLER_MOVE_AXIS = 1 ; // Change for your controller public static final int DRIVER_CONTROLLER_ROTATE_AXIS = 2 ; // Change for your controller } Your full DriveArcade.java should look like this: package frc.robot.commands ; import edu.wpi.first.wpilibj.command.Command ; import frc.robot.Robot ; import frc.robot.RobotMap ; public class DriveArcade extends Command { public DriveArcade () { // Use requires() here to declare subsystem dependencies // eg. requires(chassis); requires ( Robot . m_drivetrain ); } // Called just before this Command runs the first time @Override protected void initialize () { } // Called repeatedly when this Command is scheduled to run @Override protected void execute () { double moveSpeed = - Robot . m_oi . driverController . getRawAxis ( RobotMap . DRIVER_CONTROLLER_MOVE_AXIS ); double rotateSpeed = Robot . m_oi . driverController . getRawAxis ( RobotMap . DRIVER_CONTROLLER_ROTATE_AXIS ); Robot . m_drivetrain . arcadeDrive ( moveSpeed , rotateSpeed ); } // Make this return true when this Command no longer needs to run execute() @Override protected boolean isFinished () { return false ; } // Called once after isFinished returns true @Override protected void end () { Robot . m_drivetrain . arcadeDrive ( 0 , 0 ); } // Called when another command which requires one or more of the same // subsystems is scheduled to run @Override protected void interrupted () { end (); } } Setting initDefaultCommand # Commands within this method run when the robot is enabled. They also run if no other commands using the subsystem are running. This is why we write requires(Robot.m_subsystemName) in the commands we create, it ends currently running commands using that subsystem to allow a new command is run. 1) Back in Drivetrain.java in the initDefaultCommand() method we will put our newly created command In the initDefaultCommand() method type: setDefaultCommand ( new DriveArcade ()); Tip Remember to use the light bulb for importing if needed! Example The code you type should be this: setDefaultCommand ( new DriveArcade ()); Your full Drivetrain.java should look like this: package frc.robot.subsystems ; import edu.wpi.first.wpilibj.SpeedControllerGroup ; import edu.wpi.first.wpilibj.Talon ; import edu.wpi.first.wpilibj.command.Subsystem ; import edu.wpi.first.wpilibj.drive.DifferentialDrive ; import frc.robot.RobotMap ; import frc.robot.commands.DriveArcade ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; SpeedControllerGroup leftMotors = null ; SpeedControllerGroup rightMotors = null ; DifferentialDrive differentialDrive = null ; public Drivetrain () { // Talons leftFrontTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_FRONT_TALON ); leftBackTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_BACK_TALON ); rightFrontTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_FRONT_TALON ); rightBackTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_BACK_TALON ); leftMotors = new SpeedControllerGroup ( leftFrontTalon , leftBackTalon ); rightMotors = new SpeedControllerGroup ( rightFrontTalon , rightBackTalon ); differentialDrive = new DifferentialDrive ( leftMotors , rightMotors ); } public void arcadeDrive ( double moveSpeed , double rotateSpeed ) { differentialDrive . arcadeDrive ( moveSpeed , rotateSpeed ); } @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); setDefaultCommand ( new DriveArcade ()); } }","title":"Creating a Basic Driving Robot"},{"location":"programming/driving_robot.html#creating-a-basic-driving-robot","text":"Lets get moving! Picture source: Team 2984","title":"Creating a Basic Driving Robot"},{"location":"programming/driving_robot.html#overview","text":"In this section we will be going over: Creating the basic Drivetrain subsystem Adding subsystems to Robot.java, the main file that the robot runs and all other files must be in some way connected to. Creating joysticks and using their axes to control the robot. Creating and using DifferentialDrive and ArcadeDrive to make controlling the robot\u2019s motors an easy process. Deploying code to the roboRIO","title":"Overview"},{"location":"programming/driving_robot.html#creating-the-drivetrain-subsystem","text":"Before we begin we must create the class file for the drivetrain subsystem. See Creating a New Subsystem for info on how to do this.","title":"Creating the Drivetrain Subsystem"},{"location":"programming/driving_robot.html#what-will-be-added-to-the-drivetrain","text":"In the Drivetrain class we will tell the subsystem what type of components it will be using. A Drivetrain needs motor controllers. In our case we will use 4 Talon SRs (a brand of controller for motors). You could use other motor controllers such as Victor SPs or Talon SRXs but we will be using Talon SRs If you are, replace Talon with TalonSRX, Victor, or VictorSP in the code you write depending on the type you use. You can use 2 motors (left and right), but for this tutorial we will use 4. Tip Be sure to read Visual Studio Code Tips before getting started! It will make your life a lot easier.","title":"What will be added to the Drivetrain"},{"location":"programming/driving_robot.html#creating-the-talon-variables","text":"1) Create 4 global variables of data type Talon and name them: leftFrontTalon , rightFrontTalon , leftBackTalon , rightBackTalon To get started type the word Talon followed by the name i.e. Talon leftFrontTalon ; These will eventually hold the object values for Talons and their port numbers. 2) Next assign their values to null ( more info on null ). We do this to make sure it is empty at this point. When we assign these variables a value, we will be getting the motor controller's port numbers out of RobotMap This means we cannot assign them at the global level Example The code you typed should be this: Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; Your full Drivetrain.java should look like this: package frc.robot.subsystems ; import edu.wpi.first.wpilibj.Talon ; import edu.wpi.first.wpilibj.command.Subsystem ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } } If an error occurs (red squiggles) Click the word Talon \ud83d\udca1 Click the light bulb Select \"Import 'Talon' (edu.wpi.first.wpilibj)\" Your error should be gone!","title":"Creating the Talon Variables"},{"location":"programming/driving_robot.html#creating-and-filling-the-constructor","text":"1) Create the constructor for Drivetrain.java ( more info on constructors ) The constructor is where we will assign values to our talon variables. Now that we have created the Talons we must initialize them and tell them what port on the roboRIO they are on. 2) Initialize (set value of) leftFrontTalon to new Talon ( 0 ) . This initializes a new talon, leftFrontTalon , in a new piece of memory and states it is on port 0 of the roboRIO. This should be done within the constructor Drivetrain () This calls the constructor Talon ( int ) in the Talon class. The constructor Talon ( int ) takes a variable of type int . In this case the int (integer) refers to the port number on the roboRIO. roboRIO port diagram Example The code you typed should be this: public Drivetrain () { // Talons leftFrontTalon = new Talon ( 0 ); } Your full Drivetrain.java should look like this: package frc.robot.subsystems ; import edu.wpi.first.wpilibj.Talon ; import edu.wpi.first.wpilibj.command.Subsystem ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; public Drivetrain () { // Talons leftFrontTalon = new Talon ( 0 ); } @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } }","title":"Creating and filling the constructor"},{"location":"programming/driving_robot.html#using-robotmap","text":"Since each subsystem has its own components with their own ports, it is easy to lose track of which ports are being used and for what. To counter this you can use a class called RobotMap to hold all these values in a single location. 1) To use RobotMap, instead of putting 0 for the port on the Talon type: RobotMap . DRIVETRAIN_LEFT_FRONT_TALON Names should follow the pattern SUBSYSTEM_NAME_OF_COMPONENT The name is all caps since it is a constant ( more info on constants ). 2) Click on the underlined text 3) Click on the \ud83d\udca1light bulb and select \u201ccreate constant\u2026\u201d 4) Click on RobotMap.java tab that just popped up 5) Change the 0 to the correct port for that motor controller on your robot/roboRIO Danger If you set this to the wrong value, you could damage your robot when it tries to move! 6) Repeat these steps for the remaining Talons. Tip Remember to save both Drivetrain.java and RobotMap.java Example The code you type should be this: leftFrontTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_FRONT_TALON ); Your full Drivetrain.java should look like this: package frc.robot.subsystems ; import edu.wpi.first.wpilibj.Talon ; import edu.wpi.first.wpilibj.command.Subsystem ; import frc.robot.RobotMap ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; public Drivetrain () { // Talons leftFrontTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_FRONT_TALON ); leftBackTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_BACK_TALON ); rightFrontTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_FRONT_TALON ); rightBackTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_BACK_TALON ); } @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } } Your full RobotMap.java should look similar to this: package frc.robot ; public class RobotMap { // Talons public static final int DRIVETRAIN_LEFT_FRONT_TALON = 0 ; public static final int DRIVETRAIN_LEFT_BACK_TALON = 1 ; public static final int DRIVETRAIN_RIGHT_FRONT_TALON = 2 ; public static final int DRIVETRAIN_RIGHT_BACK_TALON = 3 ; } Warning Remember to use the values for YOUR specific robot or you could risk damaging it!","title":"Using RobotMap"},{"location":"programming/driving_robot.html#creating-the-arcade-drive","text":"","title":"Creating the arcade drive"},{"location":"programming/driving_robot.html#what-is-the-drive-class","text":"The FIRST Drive class has many pre-configured methods available to us including DifferentialDrive, and many alterations of MecanumDrive. DifferentialDrive contains subsections such as TankDrive and ArcadeDrive. For our tutorial we will be creating an ArcadeDrive Arcade drives run by taking a moveSpeed and rotateSpeed. moveSpeed defines the forward and reverse speed and rotateSpeed defines the turning left and right speed. To create an arcade drive we will be using our already existing Drivetrain class and adding to it.","title":"What is the Drive Class"},{"location":"programming/driving_robot.html#programing-a-robotdrive","text":"1) In the same place we created our talons (outside of the constructor) we will create a DifferentialDrive and SpeedControllerGroups for our left and right motor controllers. Outside of the constructor type: SpeedControllerGroup leftMotors = null ; SpeedControllerGroup rightMotors = null ; DifferentialDrive differentialDrive = null ; Since DifferentialDrive only takes 2 parameters we need to create speed controller groups to combine like motor controllers together. In this case we will combine the left motors together and the right motors together. Warning You should only group motors that are spinning the same direction physically when positive power is being applied otherwise you could damage your robot. 2) Now we must initialize the SpeedControllerGroups and DifferentialDrive like we did our talons. ... In the constructor type: leftMotors = new SpeedControllerGroup ( leftFrontTalon , leftBackTalon ); rightMotors = new SpeedControllerGroup ( rightFrontTalon , rightBackTalon ); differentialDrive = new DifferentialDrive ( leftMotors , rightMotors ); Example The code you type outside the constructor should be this: SpeedControllerGroup leftMotors = null ; SpeedControllerGroup rightMotors = null ; DifferentialDrive differentialDrive = null ; The code you type inside the constructor should be this: leftMotors = new SpeedControllerGroup ( leftFrontTalon , leftBackTalon ); rightMotors = new SpeedControllerGroup ( rightFrontTalon , rightBackTalon ); differentialDrive = new DifferentialDrive ( leftMotors , rightMotors ); Your full Drivetrain.java should look like this: package frc.robot.subsystems ; import edu.wpi.first.wpilibj.SpeedControllerGroup ; import edu.wpi.first.wpilibj.Talon ; import edu.wpi.first.wpilibj.command.Subsystem ; import edu.wpi.first.wpilibj.drive.DifferentialDrive ; import frc.robot.RobotMap ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; SpeedControllerGroup leftMotors = null ; SpeedControllerGroup rightMotors = null ; DifferentialDrive differentialDrive = null ; public Drivetrain () { // Talons leftFrontTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_FRONT_TALON ); leftBackTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_BACK_TALON ); rightFrontTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_FRONT_TALON ); rightBackTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_BACK_TALON ); leftMotors = new SpeedControllerGroup ( leftFrontTalon , leftBackTalon ); rightMotors = new SpeedControllerGroup ( rightFrontTalon , rightBackTalon ); differentialDrive = new DifferentialDrive ( leftMotors , rightMotors ); } @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } }","title":"Programing a RobotDrive"},{"location":"programming/driving_robot.html#creating-the-arcadedrive-method","text":"Now it\u2019s time to make an arcadeDrive from our differentialDrive! 1) Let\u2019s create a public void method called \u201carcadeDrive\u201d with type \u201cdouble\u201d parameters moveSpeed and rotateSpeed. Below the constructor type: public void arcadeDrive ( double moveSpeed , double rotateSpeed ) { } Tip By putting something in the parentheses it makes the method require a parameter when it is used. When the method gets used and parameters are passed, they will be store in moveSpeed and rotateSpeed (in that order). See parameters for more info. 2) Now lets make our method call the differentialDrive's arcadeDrive method. Inside our method type: differentialDrive . arcadeDrive ( moveSpeed , rotateSpeed ); DifferentialDrive's arcadeDrive method takes parameters moveValue and rotateValue. Note At this point you could instead create a tank drive, however implementation differs slightly. To do so type differentialDrive . tankDrive ( moveSpeed , rotateSpeed ); instead of differentialDrive . arcadeDrive ( moveSpeed , rotateSpeed ); and change the method name reflect this. Tip If you want to limit the max speed you can multiple the speeds by a decimal (i.e. 0.5*moveSpeed will make the motors only move half of their maximum speed) You may want to do this for initial testing to make sure everything is going the right direction. Example The code you type should be this: public void arcadeDrive ( double moveSpeed , double rotateSpeed ) { differentialDrive . arcadeDrive ( moveSpeed , rotateSpeed ); } Your full Drivetrain.java should look like this: package frc.robot.subsystems ; import edu.wpi.first.wpilibj.SpeedControllerGroup ; import edu.wpi.first.wpilibj.Talon ; import edu.wpi.first.wpilibj.command.Subsystem ; import edu.wpi.first.wpilibj.drive.DifferentialDrive ; import frc.robot.RobotMap ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; SpeedControllerGroup leftMotors = null ; SpeedControllerGroup rightMotors = null ; DifferentialDrive differentialDrive = null ; public Drivetrain () { // Talons leftFrontTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_FRONT_TALON ); leftBackTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_BACK_TALON ); rightFrontTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_FRONT_TALON ); rightBackTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_BACK_TALON ); leftMotors = new SpeedControllerGroup ( leftFrontTalon , leftBackTalon ); rightMotors = new SpeedControllerGroup ( rightFrontTalon , rightBackTalon ); differentialDrive = new DifferentialDrive ( leftMotors , rightMotors ); } public void arcadeDrive ( double moveSpeed , double rotateSpeed ) { differentialDrive . arcadeDrive ( moveSpeed , rotateSpeed ); } @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } }","title":"Creating the arcadeDrive method"},{"location":"programming/driving_robot.html#making-our-robot-controllable","text":"","title":"Making our robot controllable"},{"location":"programming/driving_robot.html#creating-the-joystick","text":"In order to drive our robot, it needs to know what will be controlling it. To do so, we will create a new joystick in OI.java 1) Open OI.java 2) Type: public Joystick driverController = new Joystick ( RobotMap . OI_DRIVER_CONTROLLER ); Import any classes if necessary such as: import edu.wpi.first.wpilibj.Joystick ; A variable driverController of type Joystick pointing to a joystick on port OI_DRIVER_CONTROLLER from RobotMap 3) Click the \ud83d\udca1 light bulb to create a new CONSTANT and set the value to the port number the joystick uses on the laptop (this can be found in the Driverstation software). Example The code you type should be this: public Joystick driverController = new Joystick ( RobotMap . OI_DRIVER_CONTROLLER ); Your full OI.java should look like this: package frc.robot ; import edu.wpi.first.wpilibj.Joystick ; /** * This class is the glue that binds the controls on the physical operator * interface to the commands and command groups that allow control of the robot. */ public class OI { public Joystick driverController = new Joystick ( RobotMap . OI_DRIVER_CONTROLLER ); } Your full RobotMap.java should look similar to this: package frc.robot ; public class RobotMap { // Talons public static final int DRIVETRAIN_LEFT_FRONT_TALON = 0 ; public static final int DRIVETRAIN_LEFT_BACK_TALON = 1 ; public static final int DRIVETRAIN_RIGHT_FRONT_TALON = 2 ; public static final int DRIVETRAIN_RIGHT_BACK_TALON = 3 ; // Joysticks public static final int OI_DRIVER_CONTROLLER = 0 ; }","title":"Creating the Joystick"},{"location":"programming/driving_robot.html#creating-the-drivearcade-command","text":"Remember that methods tell the robot what it can do but in order to make it do these things we must give it a command . See Command Based Robot Now that we have created the method, we need to create a command to call and use that method. Let\u2019s create a new command called DriveArcade that calls arcadeDrive method we just created! Before we begin we must create the class file for the DriveArcade command. See Creating a New Command for info on how to do this and info on what each pre-created method does.","title":"Creating the DriveArcade Command"},{"location":"programming/driving_robot.html#in-the-constructor","text":"1) In the constructor DriveArcade () type: requires ( Robot . m_drivetrain ); This means, this command will end all other commands currently using drivetrain and will run instead when executed. It also means, other commands that require drivetrain will stop this command and run instead when executed. Warning If you use the light bulb to import \u2018Robot\u2019. Be sure to import the one with \u201cfrc.robot\u201d","title":"In the constructor"},{"location":"programming/driving_robot.html#in-the-execute-method","text":"1) In the execute method we will create 2 variables of type double called moveSpeed and rotateSpeed. We want these variables to be the value of the axis of the controller we are using to drive the robot. So we will set them equal to that by using the joystick getRawAxis method. Controllers return an axis value between 1 and -1 to indicate how far the joystick is pushed up or down. Our personal controller returns up as -1 so we want to invert it. In Java you can put a negative \u201c - \u201cin front of a numeric value to invert it (value * -1) The joystick\u2019s getRawAxis method will get the position value of the axis as you move it. The method takes parameter \u201caxis number.\u201d (This can be found in the Driverstation software and we will store it in RobotMap). In the execute() method type: double moveSpeed = - Robot . m_oi . driverController . getRawAxis ( RobotMap . DRIVER_CONTROLLER_MOVE_AXIS ); double rotateSpeed = Robot . m_oi . driverController . getRawAxis ( RobotMap . DRIVER_CONTROLLER_ROTATE_AXIS ); Tip Remember to use the light bulb for importing and creating constants if needed! 2) Also in the execute method we will we want to call the arcadeDrive method we created in Drivetrain and give it the variables moveSpeed and rotateSpeed we created as parameters. In the execute() method below rotateSpeed type: Robot . m_drivetrain . arcadeDrive ( moveSpeed , rotateSpeed );","title":"In the execute method"},{"location":"programming/driving_robot.html#in-the-isfinished-method","text":"Since we will be using this command to control the robot we want it to run indefinitely. 1) To do this we are going to continue having isFinished return false, meaning the command will never finish. (We don't need to change anything as this is the default) Tip If we did want a command to finish, we make this return true. This can be done by replacing false with true to make it finish instantly Alternatively we can make a condition which can return true For example (timePassed > 10) will return true after 10 seconds but return false anytime before 10 seconds have passed.","title":"In the isFinished method"},{"location":"programming/driving_robot.html#in-the-end-method","text":"1) We will call the arcadeDrive method and give it 0 and 0 as the parameters. In the end() method type: Robot . m_drivetrain . arcadeDrive ( 0 , 0 ); This make the motors stop running when the command ends by setting the movement speed to zero and rotation speed to zero.","title":"In the end method"},{"location":"programming/driving_robot.html#in-the-interrupted-method","text":"1) We will make it call end. In the interrupted() method type: end (); This makes the end method get called if the command gets interrupted. (No reason to re-write code, call end() to use what we already have!)","title":"In the interrupted method"},{"location":"programming/driving_robot.html#completed-example","text":"Example Your full RobotMap.java should look similar to this: package frc.robot ; public class RobotMap { // Talons public static final int DRIVETRAIN_LEFT_FRONT_TALON = 0 ; public static final int DRIVETRAIN_LEFT_BACK_TALON = 1 ; public static final int DRIVETRAIN_RIGHT_FRONT_TALON = 2 ; public static final int DRIVETRAIN_RIGHT_BACK_TALON = 3 ; // Joysticks public static final int OI_DRIVER_CONTROLLER = 0 ; public static final int DRIVER_CONTROLLER_MOVE_AXIS = 1 ; // Change for your controller public static final int DRIVER_CONTROLLER_ROTATE_AXIS = 2 ; // Change for your controller } Your full DriveArcade.java should look like this: package frc.robot.commands ; import edu.wpi.first.wpilibj.command.Command ; import frc.robot.Robot ; import frc.robot.RobotMap ; public class DriveArcade extends Command { public DriveArcade () { // Use requires() here to declare subsystem dependencies // eg. requires(chassis); requires ( Robot . m_drivetrain ); } // Called just before this Command runs the first time @Override protected void initialize () { } // Called repeatedly when this Command is scheduled to run @Override protected void execute () { double moveSpeed = - Robot . m_oi . driverController . getRawAxis ( RobotMap . DRIVER_CONTROLLER_MOVE_AXIS ); double rotateSpeed = Robot . m_oi . driverController . getRawAxis ( RobotMap . DRIVER_CONTROLLER_ROTATE_AXIS ); Robot . m_drivetrain . arcadeDrive ( moveSpeed , rotateSpeed ); } // Make this return true when this Command no longer needs to run execute() @Override protected boolean isFinished () { return false ; } // Called once after isFinished returns true @Override protected void end () { Robot . m_drivetrain . arcadeDrive ( 0 , 0 ); } // Called when another command which requires one or more of the same // subsystems is scheduled to run @Override protected void interrupted () { end (); } }","title":"Completed Example"},{"location":"programming/driving_robot.html#setting-initdefaultcommand","text":"Commands within this method run when the robot is enabled. They also run if no other commands using the subsystem are running. This is why we write requires(Robot.m_subsystemName) in the commands we create, it ends currently running commands using that subsystem to allow a new command is run. 1) Back in Drivetrain.java in the initDefaultCommand() method we will put our newly created command In the initDefaultCommand() method type: setDefaultCommand ( new DriveArcade ()); Tip Remember to use the light bulb for importing if needed! Example The code you type should be this: setDefaultCommand ( new DriveArcade ()); Your full Drivetrain.java should look like this: package frc.robot.subsystems ; import edu.wpi.first.wpilibj.SpeedControllerGroup ; import edu.wpi.first.wpilibj.Talon ; import edu.wpi.first.wpilibj.command.Subsystem ; import edu.wpi.first.wpilibj.drive.DifferentialDrive ; import frc.robot.RobotMap ; import frc.robot.commands.DriveArcade ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null ; Talon leftBackTalon = null ; Talon rightFrontTalon = null ; Talon rightBackTalon = null ; SpeedControllerGroup leftMotors = null ; SpeedControllerGroup rightMotors = null ; DifferentialDrive differentialDrive = null ; public Drivetrain () { // Talons leftFrontTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_FRONT_TALON ); leftBackTalon = new Talon ( RobotMap . DRIVETRAIN_LEFT_BACK_TALON ); rightFrontTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_FRONT_TALON ); rightBackTalon = new Talon ( RobotMap . DRIVETRAIN_RIGHT_BACK_TALON ); leftMotors = new SpeedControllerGroup ( leftFrontTalon , leftBackTalon ); rightMotors = new SpeedControllerGroup ( rightFrontTalon , rightBackTalon ); differentialDrive = new DifferentialDrive ( leftMotors , rightMotors ); } public void arcadeDrive ( double moveSpeed , double rotateSpeed ) { differentialDrive . arcadeDrive ( moveSpeed , rotateSpeed ); } @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); setDefaultCommand ( new DriveArcade ()); } }","title":"Setting initDefaultCommand"},{"location":"programming/new_project.html","text":"Creating Project Files # Lets get started Overview # Before we can start programing a robot, we must create a new project in Visual Studio Code (VSCode). This section will go over: Creating a New Project Creating a New Subsystem Creating a New Command Creating a New Project # 1) Select the W icon from the tab bar or use the shortcut by holding down Ctrl+Shift+P at the same time. (Replace ctrl with command on macOS) 2) Type and hit enter or select WPILib: Create a new project 3) Click Select a Project Type and choose Template 4) Click Select a Language and choose Java 5) Click Select a project base and choose Command Robot 6) Click Select a new project folder and choose where on your computer you would like to store the program 7) Enter a project name in the text field labeled as such 8) Enter your team number in the text field labeled as such 9) Select Generate Project 10) When prompted \u201cWould you like to open the folder?\u201d , select Yes (Current Window) Default Project Contents # Newly created projects have many files within them. We only care about the contents within the src/main/java/frc/robot/ folder. Everything else can be ignored at this point in the tutorial. Files in the robot folder: ExampleCommand.java An example Command ExampleSubsystem.java An example SubSystem Main.java Used for advanced programming Will be ignored/left as is for this tutorial OI.java Used to create a connection between commands and Operator Interfaces (OI) such as Joysticks or buttons Robot.java Used to declare our subsystem Used to run special methods in the init and period phases of the auto, teleop, and disabled states RobotMap.java Used to map physical ports (digital if using the CAN bus) to variables in the code Example Creating a New Subsystem # 1) Click on the src folder to expand it. 2) Do the same for subsystems 3) Right click on subsystems and select Create a new class/ command. 4) Select Subsystem and type your DesiredSubsystemName (i.e. Drivetrain ) for the name and hit enter on your keyboard. 5) Click on the newly create DesiredSubsystemName.java (or Drivetrain.java if you named it that) Adding the Subsystem to Robot.java # Do not forget this step! When a robot program runs on the roboRIO it only runs the main file Robot.java and anything Robot.java links to. We have created a new subsystem but we have not yet linked it to Robot.java. We must do this for EVERY subsystem we create 1) In Robot.java we will create a new global variable of type DesiredSubsystemName (i.e. Drivetrain ) named m_desiredSubsystemName ( i.e. m_drivetrain ) and set its value to null . 2) In the robotInit() method add: m_desiredSubsystemName = new DesiredSubsystemName (); (i.e. m_drivetrain = new Drivetrain (); ) Important This must always be done above OI and Telemetry/SmartDashboard (if present). Now when we use this subsystem in commands, we must call Robot . m_desiredSubsystemName . to get access to it and its methods. (i.e. Robot . m_drivetrain . someMethod () ) Default Subsystem Contents # Newly created subsystems are empty with the exception of the initDefaultCommand. Currently there is no constructor, we will create a constructor ourselves later. initDefaultCommand - a command that will run automatically every time the subsystem is called. When another command that requires the same subsystem is called, the initDefaultCommand will stop and restart after the new command has finished. This process calls the interrupted method of the command being called initDefaultCommand Example package frc.robot.subsystems ; import edu.wpi.first.wpilibj.command.Subsystem ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } } Creating a New Command # 1) Click on the src folder to expand it (if it isn't already). 2) Do the same for commands 3) Right click on commands and select Create a new class/ command. 4) Select Command and type DesiredCommandName (i.e. DriveArcade) for the name and hit enter on your keyboard. 5) Click on the newly create DesiredCommandName.java (or DriveArcade.java if you named it that) Default Command Contents # Newly created commands have some predefined methods in them specific for a command based robot. Constructor - Called when the robot program is FIRST loaded. Subsystem dependencies are declared here. initialize() - Called ONCE just before this Command runs the first time. execute() - Called REPEATEDLY when this Command is scheduled to run isFinished() - Make this return TRUE when this Command no longer needs to run execute() (initialize always runs once regardless). end() - Called ONCE after isFinished returns true interrupted() - Called when another command which requires one or more of the same subsystems is scheduled to run Example package frc.robot.commands ; import edu.wpi.first.wpilibj.command.Command ; public class ArcadeDrive extends Command { public ArcadeDrive () { // Use requires() here to declare subsystem dependencies // eg. requires(chassis); } // Called just before this Command runs the first time @Override protected void initialize () { } // Called repeatedly when this Command is scheduled to run @Override protected void execute () { } // Make this return true when this Command no longer needs to run execute() @Override protected boolean isFinished () { return false ; } // Called once after isFinished returns true @Override protected void end () { } // Called when another command which requires one or more of the same // subsystems is scheduled to run @Override protected void interrupted () { } }","title":"Creating Project Files"},{"location":"programming/new_project.html#creating-project-files","text":"Lets get started","title":"Creating Project Files"},{"location":"programming/new_project.html#overview","text":"Before we can start programing a robot, we must create a new project in Visual Studio Code (VSCode). This section will go over: Creating a New Project Creating a New Subsystem Creating a New Command","title":"Overview"},{"location":"programming/new_project.html#creating-a-new-project","text":"1) Select the W icon from the tab bar or use the shortcut by holding down Ctrl+Shift+P at the same time. (Replace ctrl with command on macOS) 2) Type and hit enter or select WPILib: Create a new project 3) Click Select a Project Type and choose Template 4) Click Select a Language and choose Java 5) Click Select a project base and choose Command Robot 6) Click Select a new project folder and choose where on your computer you would like to store the program 7) Enter a project name in the text field labeled as such 8) Enter your team number in the text field labeled as such 9) Select Generate Project 10) When prompted \u201cWould you like to open the folder?\u201d , select Yes (Current Window)","title":"Creating a New Project"},{"location":"programming/new_project.html#default-project-contents","text":"Newly created projects have many files within them. We only care about the contents within the src/main/java/frc/robot/ folder. Everything else can be ignored at this point in the tutorial. Files in the robot folder: ExampleCommand.java An example Command ExampleSubsystem.java An example SubSystem Main.java Used for advanced programming Will be ignored/left as is for this tutorial OI.java Used to create a connection between commands and Operator Interfaces (OI) such as Joysticks or buttons Robot.java Used to declare our subsystem Used to run special methods in the init and period phases of the auto, teleop, and disabled states RobotMap.java Used to map physical ports (digital if using the CAN bus) to variables in the code Example","title":"Default Project Contents"},{"location":"programming/new_project.html#creating-a-new-subsystem","text":"1) Click on the src folder to expand it. 2) Do the same for subsystems 3) Right click on subsystems and select Create a new class/ command. 4) Select Subsystem and type your DesiredSubsystemName (i.e. Drivetrain ) for the name and hit enter on your keyboard. 5) Click on the newly create DesiredSubsystemName.java (or Drivetrain.java if you named it that)","title":"Creating a New Subsystem"},{"location":"programming/new_project.html#adding-the-subsystem-to-robotjava","text":"Do not forget this step! When a robot program runs on the roboRIO it only runs the main file Robot.java and anything Robot.java links to. We have created a new subsystem but we have not yet linked it to Robot.java. We must do this for EVERY subsystem we create 1) In Robot.java we will create a new global variable of type DesiredSubsystemName (i.e. Drivetrain ) named m_desiredSubsystemName ( i.e. m_drivetrain ) and set its value to null . 2) In the robotInit() method add: m_desiredSubsystemName = new DesiredSubsystemName (); (i.e. m_drivetrain = new Drivetrain (); ) Important This must always be done above OI and Telemetry/SmartDashboard (if present). Now when we use this subsystem in commands, we must call Robot . m_desiredSubsystemName . to get access to it and its methods. (i.e. Robot . m_drivetrain . someMethod () )","title":"Adding the Subsystem to Robot.java"},{"location":"programming/new_project.html#default-subsystem-contents","text":"Newly created subsystems are empty with the exception of the initDefaultCommand. Currently there is no constructor, we will create a constructor ourselves later. initDefaultCommand - a command that will run automatically every time the subsystem is called. When another command that requires the same subsystem is called, the initDefaultCommand will stop and restart after the new command has finished. This process calls the interrupted method of the command being called initDefaultCommand Example package frc.robot.subsystems ; import edu.wpi.first.wpilibj.command.Subsystem ; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. @Override public void initDefaultCommand () { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } }","title":"Default Subsystem Contents"},{"location":"programming/new_project.html#creating-a-new-command","text":"1) Click on the src folder to expand it (if it isn't already). 2) Do the same for commands 3) Right click on commands and select Create a new class/ command. 4) Select Command and type DesiredCommandName (i.e. DriveArcade) for the name and hit enter on your keyboard. 5) Click on the newly create DesiredCommandName.java (or DriveArcade.java if you named it that)","title":"Creating a New Command"},{"location":"programming/new_project.html#default-command-contents","text":"Newly created commands have some predefined methods in them specific for a command based robot. Constructor - Called when the robot program is FIRST loaded. Subsystem dependencies are declared here. initialize() - Called ONCE just before this Command runs the first time. execute() - Called REPEATEDLY when this Command is scheduled to run isFinished() - Make this return TRUE when this Command no longer needs to run execute() (initialize always runs once regardless). end() - Called ONCE after isFinished returns true interrupted() - Called when another command which requires one or more of the same subsystems is scheduled to run Example package frc.robot.commands ; import edu.wpi.first.wpilibj.command.Command ; public class ArcadeDrive extends Command { public ArcadeDrive () { // Use requires() here to declare subsystem dependencies // eg. requires(chassis); } // Called just before this Command runs the first time @Override protected void initialize () { } // Called repeatedly when this Command is scheduled to run @Override protected void execute () { } // Make this return true when this Command no longer needs to run execute() @Override protected boolean isFinished () { return false ; } // Called once after isFinished returns true @Override protected void end () { } // Called when another command which requires one or more of the same // subsystems is scheduled to run @Override protected void interrupted () { } }","title":"Default Command Contents"},{"location":"programming/pid.html","text":"WIP Getting started with PID # This page is currently a work in progress. Check back later","title":"**WIP** Getting started with PID"},{"location":"programming/pid.html#wip-getting-started-with-pid","text":"This page is currently a work in progress. Check back later","title":"WIP Getting started with PID"},{"location":"programming/pneumatics.html","text":"WIP Using Pneumatics # This page is currently a work in progress. Check back later","title":"**WIP** Using Pneumatics"},{"location":"programming/pneumatics.html#wip-using-pneumatics","text":"This page is currently a work in progress. Check back later","title":"WIP Using Pneumatics"},{"location":"programming/robotpreferences.html","text":"WIP Using RobotPreferences # This page is currently a work in progress. Check back later","title":"**WIP** Using RobotPreferences"},{"location":"programming/robotpreferences.html#wip-using-robotpreferences","text":"This page is currently a work in progress. Check back later","title":"WIP Using RobotPreferences"},{"location":"programming/shuffleboard.html","text":"WIP Using Shuffleboard # This page is currently a work in progress. Check back later","title":"**WIP** Using Shuffleboard"},{"location":"programming/shuffleboard.html#wip-using-shuffleboard","text":"This page is currently a work in progress. Check back later","title":"WIP Using Shuffleboard"},{"location":"programming/super_core.html","text":"WIP Using SuperCORE # This page is currently a work in progress. Check back later","title":"**WIP** Using SuperCORE"},{"location":"programming/super_core.html#wip-using-supercore","text":"This page is currently a work in progress. Check back later","title":"WIP Using SuperCORE"},{"location":"programming/using_sensors.html","text":"WIP Using Sensors and Switches # This page is currently a work in progress. Check back later","title":"**WIP** Using Sensors and Switches"},{"location":"programming/using_sensors.html#wip-using-sensors-and-switches","text":"This page is currently a work in progress. Check back later","title":"WIP Using Sensors and Switches"},{"location":"setup/3rd_party_libs.html","text":"","title":"3rd party libs"},{"location":"setup/configure_radio.html","text":"","title":"Configure radio"},{"location":"setup/imaging_roboRIO.html","text":"","title":"imaging roboRIO"},{"location":"setup/install_software.html","text":"Installing Necessary Software # Lets get started Overview # Before we can start programing a robot we must install the necessary software for programming and driving the robot. This section will go over: Installing Development Tools: VSCode and Java Installing the FRC Update Suite: Driverstation Software and roboRIO imaging tool Tip You can install both the Development Tools and the FRC Update Suite on the same computer or separate computers. Many teams (3255 included) have a development laptop (with both) and a driverstation laptop (with only the FRC Update Suite). Installing Java Development Tools # If all you are doing is writing and deploying code to a robot, all you need are the development tools. Following the instructions linked below will get you set up with a development environment and get you setup with all the tools necessary to program a robot. Installing Java and Visual Studio Code (VSCode) # For Windows, macOS, or Linux: Official 2019 FRC installation guide (Windows, macOS, or Linux) IMPORTANT NOTE These tools only allow you to program and deploy code to an already imaged roboRIO. They do not allow you to drive the robot or image/update the roboRIO. To accomplish those tasks you must install the FRC Update Suite . Installing the FRC Update Suite # If all you are doing is driving an already programmed robot or imaging/updating the roboRIO all you need is the FRC Update Suite. Following the instructions linked below will get you set up with the tools to drive the robot and image/update the roboRIO. Installing the Driverstation software and roboRIO imaging tool # For Windows ONLY: Official 2019 FRC installation guide (Windows, macOS, or Linux) IMPORTANT NOTE These tools only allow you to drive the robot and image/update a roboRIO. They do not allow you to program the robot the robot. To accomplish those tasks you must install the Java Development Tools .","title":"Installing Necessary Software"},{"location":"setup/install_software.html#installing-necessary-software","text":"Lets get started","title":"Installing Necessary Software"},{"location":"setup/install_software.html#overview","text":"Before we can start programing a robot we must install the necessary software for programming and driving the robot. This section will go over: Installing Development Tools: VSCode and Java Installing the FRC Update Suite: Driverstation Software and roboRIO imaging tool Tip You can install both the Development Tools and the FRC Update Suite on the same computer or separate computers. Many teams (3255 included) have a development laptop (with both) and a driverstation laptop (with only the FRC Update Suite).","title":"Overview"},{"location":"setup/install_software.html#installing-java-development-tools","text":"If all you are doing is writing and deploying code to a robot, all you need are the development tools. Following the instructions linked below will get you set up with a development environment and get you setup with all the tools necessary to program a robot.","title":"Installing Java Development Tools"},{"location":"setup/install_software.html#installing-java-and-visual-studio-code-vscode","text":"For Windows, macOS, or Linux: Official 2019 FRC installation guide (Windows, macOS, or Linux) IMPORTANT NOTE These tools only allow you to program and deploy code to an already imaged roboRIO. They do not allow you to drive the robot or image/update the roboRIO. To accomplish those tasks you must install the FRC Update Suite .","title":"Installing Java and Visual Studio Code (VSCode)"},{"location":"setup/install_software.html#installing-the-frc-update-suite","text":"If all you are doing is driving an already programmed robot or imaging/updating the roboRIO all you need is the FRC Update Suite. Following the instructions linked below will get you set up with the tools to drive the robot and image/update the roboRIO.","title":"Installing the FRC Update Suite"},{"location":"setup/install_software.html#installing-the-driverstation-software-and-roborio-imaging-tool","text":"For Windows ONLY: Official 2019 FRC installation guide (Windows, macOS, or Linux) IMPORTANT NOTE These tools only allow you to drive the robot and image/update a roboRIO. They do not allow you to program the robot the robot. To accomplish those tasks you must install the Java Development Tools .","title":"Installing the Driverstation software and roboRIO imaging tool"}]}